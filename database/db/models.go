// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ApplicationPermissionResourceType string

const (
	ApplicationPermissionResourceTypeProject          ApplicationPermissionResourceType = "project"
	ApplicationPermissionResourceTypeLogicalPartition ApplicationPermissionResourceType = "logical-partition"
	ApplicationPermissionResourceTypeServiceItem      ApplicationPermissionResourceType = "service-item"
)

func (e *ApplicationPermissionResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ApplicationPermissionResourceType(s)
	case string:
		*e = ApplicationPermissionResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ApplicationPermissionResourceType: %T", src)
	}
	return nil
}

type NullApplicationPermissionResourceType struct {
	ApplicationPermissionResourceType ApplicationPermissionResourceType `json:"applicationPermissionResourceType"`
	Valid                             bool                              `json:"valid"` // Valid is true if ApplicationPermissionResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullApplicationPermissionResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ApplicationPermissionResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ApplicationPermissionResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullApplicationPermissionResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ApplicationPermissionResourceType), nil
}

func (e ApplicationPermissionResourceType) Valid() bool {
	switch e {
	case ApplicationPermissionResourceTypeProject,
		ApplicationPermissionResourceTypeLogicalPartition,
		ApplicationPermissionResourceTypeServiceItem:
		return true
	}
	return false
}

type GlobalActorType string

const (
	GlobalActorTypeApiKey GlobalActorType = "api-key"
	GlobalActorTypeUser   GlobalActorType = "user"
	GlobalActorTypeSigned GlobalActorType = "signed"
)

func (e *GlobalActorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalActorType(s)
	case string:
		*e = GlobalActorType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalActorType: %T", src)
	}
	return nil
}

type NullGlobalActorType struct {
	GlobalActorType GlobalActorType `json:"globalActorType"`
	Valid           bool            `json:"valid"` // Valid is true if GlobalActorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalActorType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalActorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalActorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalActorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalActorType), nil
}

func (e GlobalActorType) Valid() bool {
	switch e {
	case GlobalActorTypeApiKey,
		GlobalActorTypeUser,
		GlobalActorTypeSigned:
		return true
	}
	return false
}

type GlobalAssignableActorType string

const (
	GlobalAssignableActorTypeApiKey GlobalAssignableActorType = "api-key"
	GlobalAssignableActorTypeUser   GlobalAssignableActorType = "user"
	GlobalAssignableActorTypeAll    GlobalAssignableActorType = "all"
)

func (e *GlobalAssignableActorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalAssignableActorType(s)
	case string:
		*e = GlobalAssignableActorType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalAssignableActorType: %T", src)
	}
	return nil
}

type NullGlobalAssignableActorType struct {
	GlobalAssignableActorType GlobalAssignableActorType `json:"globalAssignableActorType"`
	Valid                     bool                      `json:"valid"` // Valid is true if GlobalAssignableActorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalAssignableActorType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalAssignableActorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalAssignableActorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalAssignableActorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalAssignableActorType), nil
}

func (e GlobalAssignableActorType) Valid() bool {
	switch e {
	case GlobalAssignableActorTypeApiKey,
		GlobalAssignableActorTypeUser,
		GlobalAssignableActorTypeAll:
		return true
	}
	return false
}

type GlobalMediaStatus string

const (
	GlobalMediaStatusPending                 GlobalMediaStatus = "pending"
	GlobalMediaStatusCompleteMultipartFailed GlobalMediaStatus = "complete-multipart-failed"
	GlobalMediaStatusFailedValidation        GlobalMediaStatus = "failed-validation"
	GlobalMediaStatusProcessing              GlobalMediaStatus = "processing"
	GlobalMediaStatusProcessingFailed        GlobalMediaStatus = "processing-failed"
	GlobalMediaStatusCompleted               GlobalMediaStatus = "completed"
)

func (e *GlobalMediaStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalMediaStatus(s)
	case string:
		*e = GlobalMediaStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalMediaStatus: %T", src)
	}
	return nil
}

type NullGlobalMediaStatus struct {
	GlobalMediaStatus GlobalMediaStatus `json:"globalMediaStatus"`
	Valid             bool              `json:"valid"` // Valid is true if GlobalMediaStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalMediaStatus) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalMediaStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalMediaStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalMediaStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalMediaStatus), nil
}

func (e GlobalMediaStatus) Valid() bool {
	switch e {
	case GlobalMediaStatusPending,
		GlobalMediaStatusCompleteMultipartFailed,
		GlobalMediaStatusFailedValidation,
		GlobalMediaStatusProcessing,
		GlobalMediaStatusProcessingFailed,
		GlobalMediaStatusCompleted:
		return true
	}
	return false
}

type GlobalMediaUploadType string

const (
	GlobalMediaUploadTypeSinglepart GlobalMediaUploadType = "singlepart"
	GlobalMediaUploadTypeMultipart  GlobalMediaUploadType = "multipart"
)

func (e *GlobalMediaUploadType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalMediaUploadType(s)
	case string:
		*e = GlobalMediaUploadType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalMediaUploadType: %T", src)
	}
	return nil
}

type NullGlobalMediaUploadType struct {
	GlobalMediaUploadType GlobalMediaUploadType `json:"globalMediaUploadType"`
	Valid                 bool                  `json:"valid"` // Valid is true if GlobalMediaUploadType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalMediaUploadType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalMediaUploadType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalMediaUploadType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalMediaUploadType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalMediaUploadType), nil
}

func (e GlobalMediaUploadType) Valid() bool {
	switch e {
	case GlobalMediaUploadTypeSinglepart,
		GlobalMediaUploadTypeMultipart:
		return true
	}
	return false
}

type GlobalServiceType string

const (
	GlobalServiceTypeCore     GlobalServiceType = "core"
	GlobalServiceTypeOptional GlobalServiceType = "optional"
)

func (e *GlobalServiceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalServiceType(s)
	case string:
		*e = GlobalServiceType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalServiceType: %T", src)
	}
	return nil
}

type NullGlobalServiceType struct {
	GlobalServiceType GlobalServiceType `json:"globalServiceType"`
	Valid             bool              `json:"valid"` // Valid is true if GlobalServiceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalServiceType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalServiceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalServiceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalServiceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalServiceType), nil
}

func (e GlobalServiceType) Valid() bool {
	switch e {
	case GlobalServiceTypeCore,
		GlobalServiceTypeOptional:
		return true
	}
	return false
}

type GlobalUserStatus string

const (
	GlobalUserStatusDisabled GlobalUserStatus = "disabled"
	GlobalUserStatusEnabled  GlobalUserStatus = "enabled"
)

func (e *GlobalUserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalUserStatus(s)
	case string:
		*e = GlobalUserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalUserStatus: %T", src)
	}
	return nil
}

type NullGlobalUserStatus struct {
	GlobalUserStatus GlobalUserStatus `json:"globalUserStatus"`
	Valid            bool             `json:"valid"` // Valid is true if GlobalUserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalUserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalUserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalUserStatus), nil
}

func (e GlobalUserStatus) Valid() bool {
	switch e {
	case GlobalUserStatusDisabled,
		GlobalUserStatusEnabled:
		return true
	}
	return false
}

type ManagementPermissionResourceType string

const (
	ManagementPermissionResourceTypeOrganization ManagementPermissionResourceType = "organization"
)

func (e *ManagementPermissionResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ManagementPermissionResourceType(s)
	case string:
		*e = ManagementPermissionResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ManagementPermissionResourceType: %T", src)
	}
	return nil
}

type NullManagementPermissionResourceType struct {
	ManagementPermissionResourceType ManagementPermissionResourceType `json:"managementPermissionResourceType"`
	Valid                            bool                             `json:"valid"` // Valid is true if ManagementPermissionResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullManagementPermissionResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ManagementPermissionResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ManagementPermissionResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullManagementPermissionResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ManagementPermissionResourceType), nil
}

func (e ManagementPermissionResourceType) Valid() bool {
	switch e {
	case ManagementPermissionResourceTypeOrganization:
		return true
	}
	return false
}

type ApplicationPermissionStaging struct {
	ID                uuid.UUID                 `json:"id"`
	ServiceID         uuid.UUID                 `json:"serviceId"`
	Key               string                    `json:"key"`
	AssignableActor   GlobalAssignableActorType `json:"assignableActor"`
	RequiredResources []string                  `json:"requiredResources"`
	Name              string                    `json:"name"`
	Description       *string                   `json:"description"`
	CreatedAt         time.Time                 `json:"createdAt"`
}

type ApplicationPermissions struct {
	ID                uuid.UUID                 `json:"id"`
	ServiceID         uuid.UUID                 `json:"serviceId"`
	Key               string                    `json:"key"`
	AssignableActor   GlobalAssignableActorType `json:"assignableActor"`
	RequiredResources []string                  `json:"requiredResources"`
	Name              string                    `json:"name"`
	Description       *string                   `json:"description"`
	CreatedAt         time.Time                 `json:"createdAt"`
}

type ArchiveDeletedRecords struct {
	ID        uuid.UUID `json:"id"`
	TableName string    `json:"tableName"`
	Record    []byte    `json:"record"`
	DeletedAt time.Time `json:"deletedAt"`
}

type ArchiveUpdatedRecords struct {
	ID            uuid.UUID       `json:"id"`
	TableName     string          `json:"tableName"`
	Old           []byte          `json:"old"`
	New           []byte          `json:"new"`
	UpdatedAt     time.Time       `json:"updatedAt"`
	UpdatedByType GlobalActorType `json:"updatedByType"`
	UpdatedBy     uuid.UUID       `json:"updatedBy"`
}

type GlobalMedia struct {
	ID               uuid.UUID             `json:"id"`
	BucketPath       string                `json:"bucketPath"`
	Size             int64                 `json:"size"`
	MimeType         string                `json:"mimeType"`
	RequiredMimeType []string              `json:"requiredMimeType"`
	Status           GlobalMediaStatus     `json:"status"`
	UploadType       GlobalMediaUploadType `json:"uploadType"`
	UploadID         *string               `json:"uploadId"`
	CreatedAt        time.Time             `json:"createdAt"`
}

type GlobalMediaImage struct {
	MediaID    uuid.UUID `json:"mediaId"`
	Thumbnail  *string   `json:"thumbnail"`
	Small      *string   `json:"small"`
	Medium     *string   `json:"medium"`
	Large      *string   `json:"large"`
	ExtraLarge *string   `json:"extraLarge"`
}

type GlobalMediaVideo struct {
	MediaID          uuid.UUID `json:"mediaId"`
	Thumbnail        *string   `json:"thumbnail"`
	AdaptiveManifest *string   `json:"adaptiveManifest"`
	Preview          *string   `json:"preview"`
}

type GlobalServices struct {
	ID          uuid.UUID         `json:"id"`
	Name        string            `json:"name"`
	Description *string           `json:"description"`
	Type        GlobalServiceType `json:"type"`
	CreatedAt   time.Time         `json:"createdAt"`
}

type GlobalUserDetails struct {
	ID                         uuid.UUID             `json:"id"`
	Email                      string                `json:"email"`
	NormalizedEmail            string                `json:"normalizedEmail"`
	Name                       *string               `json:"name"`
	NormalizedName             *string               `json:"normalizedName"`
	About                      *string               `json:"about"`
	DateOfBirth                pgtype.Date           `json:"dateOfBirth"`
	CreatedAt                  time.Time             `json:"createdAt"`
	ProfilePictureID           *uuid.UUID            `json:"profilePictureId"`
	Status                     GlobalUserStatus      `json:"status"`
	UncompressedProfilePicture *string               `json:"uncompressedProfilePicture"`
	ProfilePictureSize         *int64                `json:"profilePictureSize"`
	ProfilePictureStatus       NullGlobalMediaStatus `json:"profilePictureStatus"`
	Thumbnail                  *string               `json:"thumbnail"`
	Small                      *string               `json:"small"`
	Medium                     *string               `json:"medium"`
	Large                      *string               `json:"large"`
	ExtraLarge                 *string               `json:"extraLarge"`
}

type GlobalUserSocialLinks struct {
	ID           uuid.UUID  `json:"id"`
	PlatformName string     `json:"platformName"`
	ProfileLink  string     `json:"profileLink"`
	UserID       uuid.UUID  `json:"userId"`
	CreatedAt    time.Time  `json:"createdAt"`
	UpdatedAt    *time.Time `json:"updatedAt"`
}

type GlobalUsers struct {
	ID               uuid.UUID        `json:"id"`
	Email            string           `json:"email"`
	NormalizedEmail  string           `json:"normalizedEmail"`
	Name             *string          `json:"name"`
	NormalizedName   *string          `json:"normalizedName"`
	ProfilePictureID *uuid.UUID       `json:"profilePictureId"`
	About            *string          `json:"about"`
	DateOfBirth      pgtype.Date      `json:"dateOfBirth"`
	Status           GlobalUserStatus `json:"status"`
	CreatedAt        time.Time        `json:"createdAt"`
}

type ManagementPermissionStaging struct {
	ID                uuid.UUID                 `json:"id"`
	ServiceID         uuid.UUID                 `json:"serviceId"`
	Key               string                    `json:"key"`
	AssignableActor   GlobalAssignableActorType `json:"assignableActor"`
	RequiredResources []string                  `json:"requiredResources"`
	Name              string                    `json:"name"`
	Description       *string                   `json:"description"`
	CreatedAt         time.Time                 `json:"createdAt"`
}

type ManagementPermissions struct {
	ID                uuid.UUID                 `json:"id"`
	ServiceID         uuid.UUID                 `json:"serviceId"`
	Key               string                    `json:"key"`
	AssignableActor   GlobalAssignableActorType `json:"assignableActor"`
	RequiredResources []string                  `json:"requiredResources"`
	Name              string                    `json:"name"`
	Description       *string                   `json:"description"`
	CreatedAt         time.Time                 `json:"createdAt"`
}

type ServicesStaging struct {
	ID          uuid.UUID         `json:"id"`
	Name        string            `json:"name"`
	Description *string           `json:"description"`
	Type        GlobalServiceType `json:"type"`
	CreatedAt   time.Time         `json:"createdAt"`
}
