// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type ApplicationPermissionResourceType string

const (
	ApplicationPermissionResourceTypeProject          ApplicationPermissionResourceType = "project"
	ApplicationPermissionResourceTypeLogicalPartition ApplicationPermissionResourceType = "logical-partition"
	ApplicationPermissionResourceTypeServiceItem      ApplicationPermissionResourceType = "service-item"
)

func (e *ApplicationPermissionResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ApplicationPermissionResourceType(s)
	case string:
		*e = ApplicationPermissionResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ApplicationPermissionResourceType: %T", src)
	}
	return nil
}

type NullApplicationPermissionResourceType struct {
	ApplicationPermissionResourceType ApplicationPermissionResourceType `json:"applicationPermissionResourceType"`
	Valid                             bool                              `json:"valid"` // Valid is true if ApplicationPermissionResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullApplicationPermissionResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ApplicationPermissionResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ApplicationPermissionResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullApplicationPermissionResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ApplicationPermissionResourceType), nil
}

func (e ApplicationPermissionResourceType) Valid() bool {
	switch e {
	case ApplicationPermissionResourceTypeProject,
		ApplicationPermissionResourceTypeLogicalPartition,
		ApplicationPermissionResourceTypeServiceItem:
		return true
	}
	return false
}

type GlobalActorType string

const (
	GlobalActorTypeApiKey GlobalActorType = "api-key"
	GlobalActorTypeUser   GlobalActorType = "user"
	GlobalActorTypeSigned GlobalActorType = "signed"
)

func (e *GlobalActorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalActorType(s)
	case string:
		*e = GlobalActorType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalActorType: %T", src)
	}
	return nil
}

type NullGlobalActorType struct {
	GlobalActorType GlobalActorType `json:"globalActorType"`
	Valid           bool            `json:"valid"` // Valid is true if GlobalActorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalActorType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalActorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalActorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalActorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalActorType), nil
}

func (e GlobalActorType) Valid() bool {
	switch e {
	case GlobalActorTypeApiKey,
		GlobalActorTypeUser,
		GlobalActorTypeSigned:
		return true
	}
	return false
}

type GlobalAssignableActorType string

const (
	GlobalAssignableActorTypeApiKey GlobalAssignableActorType = "api-key"
	GlobalAssignableActorTypeUser   GlobalAssignableActorType = "user"
	GlobalAssignableActorTypeAll    GlobalAssignableActorType = "all"
)

func (e *GlobalAssignableActorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalAssignableActorType(s)
	case string:
		*e = GlobalAssignableActorType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalAssignableActorType: %T", src)
	}
	return nil
}

type NullGlobalAssignableActorType struct {
	GlobalAssignableActorType GlobalAssignableActorType `json:"globalAssignableActorType"`
	Valid                     bool                      `json:"valid"` // Valid is true if GlobalAssignableActorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalAssignableActorType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalAssignableActorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalAssignableActorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalAssignableActorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalAssignableActorType), nil
}

func (e GlobalAssignableActorType) Valid() bool {
	switch e {
	case GlobalAssignableActorTypeApiKey,
		GlobalAssignableActorTypeUser,
		GlobalAssignableActorTypeAll:
		return true
	}
	return false
}

type GlobalMediaStatus string

const (
	GlobalMediaStatusProcessing GlobalMediaStatus = "processing"
	GlobalMediaStatusFailed     GlobalMediaStatus = "failed"
	GlobalMediaStatusCompleted  GlobalMediaStatus = "completed"
)

func (e *GlobalMediaStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalMediaStatus(s)
	case string:
		*e = GlobalMediaStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalMediaStatus: %T", src)
	}
	return nil
}

type NullGlobalMediaStatus struct {
	GlobalMediaStatus GlobalMediaStatus `json:"globalMediaStatus"`
	Valid             bool              `json:"valid"` // Valid is true if GlobalMediaStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalMediaStatus) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalMediaStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalMediaStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalMediaStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalMediaStatus), nil
}

func (e GlobalMediaStatus) Valid() bool {
	switch e {
	case GlobalMediaStatusProcessing,
		GlobalMediaStatusFailed,
		GlobalMediaStatusCompleted:
		return true
	}
	return false
}

type GlobalMediaType string

const (
	GlobalMediaTypeImage GlobalMediaType = "image"
	GlobalMediaTypeVideo GlobalMediaType = "video"
	GlobalMediaTypeOther GlobalMediaType = "other"
)

func (e *GlobalMediaType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalMediaType(s)
	case string:
		*e = GlobalMediaType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalMediaType: %T", src)
	}
	return nil
}

type NullGlobalMediaType struct {
	GlobalMediaType GlobalMediaType `json:"globalMediaType"`
	Valid           bool            `json:"valid"` // Valid is true if GlobalMediaType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalMediaType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalMediaType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalMediaType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalMediaType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalMediaType), nil
}

func (e GlobalMediaType) Valid() bool {
	switch e {
	case GlobalMediaTypeImage,
		GlobalMediaTypeVideo,
		GlobalMediaTypeOther:
		return true
	}
	return false
}

type GlobalMediaUploadType string

const (
	GlobalMediaUploadTypeSinglepart GlobalMediaUploadType = "singlepart"
	GlobalMediaUploadTypeMultipart  GlobalMediaUploadType = "multipart"
)

func (e *GlobalMediaUploadType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalMediaUploadType(s)
	case string:
		*e = GlobalMediaUploadType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalMediaUploadType: %T", src)
	}
	return nil
}

type NullGlobalMediaUploadType struct {
	GlobalMediaUploadType GlobalMediaUploadType `json:"globalMediaUploadType"`
	Valid                 bool                  `json:"valid"` // Valid is true if GlobalMediaUploadType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalMediaUploadType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalMediaUploadType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalMediaUploadType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalMediaUploadType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalMediaUploadType), nil
}

func (e GlobalMediaUploadType) Valid() bool {
	switch e {
	case GlobalMediaUploadTypeSinglepart,
		GlobalMediaUploadTypeMultipart:
		return true
	}
	return false
}

type GlobalServiceHierarchyResult string

const (
	GlobalServiceHierarchyResultHierarchy GlobalServiceHierarchyResult = "hierarchy"
	GlobalServiceHierarchyResultItem      GlobalServiceHierarchyResult = "item"
)

func (e *GlobalServiceHierarchyResult) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalServiceHierarchyResult(s)
	case string:
		*e = GlobalServiceHierarchyResult(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalServiceHierarchyResult: %T", src)
	}
	return nil
}

type NullGlobalServiceHierarchyResult struct {
	GlobalServiceHierarchyResult GlobalServiceHierarchyResult `json:"globalServiceHierarchyResult"`
	Valid                        bool                         `json:"valid"` // Valid is true if GlobalServiceHierarchyResult is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalServiceHierarchyResult) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalServiceHierarchyResult, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalServiceHierarchyResult.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalServiceHierarchyResult) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalServiceHierarchyResult), nil
}

func (e GlobalServiceHierarchyResult) Valid() bool {
	switch e {
	case GlobalServiceHierarchyResultHierarchy,
		GlobalServiceHierarchyResultItem:
		return true
	}
	return false
}

type GlobalServiceHierarchyType string

const (
	GlobalServiceHierarchyTypeLevel GlobalServiceHierarchyType = "level"
	GlobalServiceHierarchyTypeTree  GlobalServiceHierarchyType = "tree"
)

func (e *GlobalServiceHierarchyType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalServiceHierarchyType(s)
	case string:
		*e = GlobalServiceHierarchyType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalServiceHierarchyType: %T", src)
	}
	return nil
}

type NullGlobalServiceHierarchyType struct {
	GlobalServiceHierarchyType GlobalServiceHierarchyType `json:"globalServiceHierarchyType"`
	Valid                      bool                       `json:"valid"` // Valid is true if GlobalServiceHierarchyType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalServiceHierarchyType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalServiceHierarchyType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalServiceHierarchyType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalServiceHierarchyType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalServiceHierarchyType), nil
}

func (e GlobalServiceHierarchyType) Valid() bool {
	switch e {
	case GlobalServiceHierarchyTypeLevel,
		GlobalServiceHierarchyTypeTree:
		return true
	}
	return false
}

type GlobalServiceLogicalPartitionType string

const (
	GlobalServiceLogicalPartitionTypeHierarchy GlobalServiceLogicalPartitionType = "hierarchy"
	GlobalServiceLogicalPartitionTypeNone      GlobalServiceLogicalPartitionType = "none"
)

func (e *GlobalServiceLogicalPartitionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalServiceLogicalPartitionType(s)
	case string:
		*e = GlobalServiceLogicalPartitionType(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalServiceLogicalPartitionType: %T", src)
	}
	return nil
}

type NullGlobalServiceLogicalPartitionType struct {
	GlobalServiceLogicalPartitionType GlobalServiceLogicalPartitionType `json:"globalServiceLogicalPartitionType"`
	Valid                             bool                              `json:"valid"` // Valid is true if GlobalServiceLogicalPartitionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalServiceLogicalPartitionType) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalServiceLogicalPartitionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalServiceLogicalPartitionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalServiceLogicalPartitionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalServiceLogicalPartitionType), nil
}

func (e GlobalServiceLogicalPartitionType) Valid() bool {
	switch e {
	case GlobalServiceLogicalPartitionTypeHierarchy,
		GlobalServiceLogicalPartitionTypeNone:
		return true
	}
	return false
}

type GlobalUserStatus string

const (
	GlobalUserStatusDisabled GlobalUserStatus = "disabled"
	GlobalUserStatusEnabled  GlobalUserStatus = "enabled"
)

func (e *GlobalUserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GlobalUserStatus(s)
	case string:
		*e = GlobalUserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for GlobalUserStatus: %T", src)
	}
	return nil
}

type NullGlobalUserStatus struct {
	GlobalUserStatus GlobalUserStatus `json:"globalUserStatus"`
	Valid            bool             `json:"valid"` // Valid is true if GlobalUserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGlobalUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.GlobalUserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GlobalUserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGlobalUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GlobalUserStatus), nil
}

func (e GlobalUserStatus) Valid() bool {
	switch e {
	case GlobalUserStatusDisabled,
		GlobalUserStatusEnabled:
		return true
	}
	return false
}

type ManagementPermissionResourceType string

const (
	ManagementPermissionResourceTypeOrganization ManagementPermissionResourceType = "organization"
)

func (e *ManagementPermissionResourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ManagementPermissionResourceType(s)
	case string:
		*e = ManagementPermissionResourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for ManagementPermissionResourceType: %T", src)
	}
	return nil
}

type NullManagementPermissionResourceType struct {
	ManagementPermissionResourceType ManagementPermissionResourceType `json:"managementPermissionResourceType"`
	Valid                            bool                             `json:"valid"` // Valid is true if ManagementPermissionResourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullManagementPermissionResourceType) Scan(value interface{}) error {
	if value == nil {
		ns.ManagementPermissionResourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ManagementPermissionResourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullManagementPermissionResourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ManagementPermissionResourceType), nil
}

func (e ManagementPermissionResourceType) Valid() bool {
	switch e {
	case ManagementPermissionResourceTypeOrganization:
		return true
	}
	return false
}

type ApplicationPermission struct {
	ID                uuid.UUID                 `json:"id"`
	ServiceID         uuid.UUID                 `json:"serviceId"`
	Key               string                    `json:"key"`
	AssignableActor   GlobalAssignableActorType `json:"assignableActor"`
	RequiredResources []string                  `json:"requiredResources"`
	Name              string                    `json:"name"`
	Description       *string                   `json:"description"`
	CreatedAt         time.Time                 `json:"createdAt"`
	UpdatedAt         time.Time                 `json:"updatedAt"`
}

type ArchiveDeletedRecord struct {
	ID        uuid.UUID `json:"id"`
	TableName string    `json:"tableName"`
	Record    []byte    `json:"record"`
	DeletedAt time.Time `json:"deletedAt"`
}

type ArchiveUpdatedRecord struct {
	ID            uuid.UUID       `json:"id"`
	TableName     string          `json:"tableName"`
	Old           []byte          `json:"old"`
	New           []byte          `json:"new"`
	UpdatedAt     time.Time       `json:"updatedAt"`
	UpdatedByType GlobalActorType `json:"updatedByType"`
	UpdatedBy     uuid.UUID       `json:"updatedBy"`
}

type GlobalMediaImage struct {
	MediaID    uuid.UUID `json:"mediaId"`
	Thumbnail  *string   `json:"thumbnail"`
	Small      *string   `json:"small"`
	Medium     *string   `json:"medium"`
	Large      *string   `json:"large"`
	ExtraLarge *string   `json:"extraLarge"`
}

type GlobalMediaVideo struct {
	MediaID          uuid.UUID `json:"mediaId"`
	Thumbnail        *string   `json:"thumbnail"`
	AdaptiveManifest *string   `json:"adaptiveManifest"`
	Preview          *string   `json:"preview"`
}

type GlobalMedium struct {
	ID          uuid.UUID         `json:"id"`
	BucketPath  string            `json:"bucketPath"`
	Size        int64             `json:"size"`
	MediaType   GlobalMediaType   `json:"mediaType"`
	ContentType string            `json:"contentType"`
	Status      GlobalMediaStatus `json:"status"`
	CreatedAt   time.Time         `json:"createdAt"`
}

type GlobalService struct {
	ID               uuid.UUID                         `json:"id"`
	Name             string                            `json:"name"`
	Assignable       bool                              `json:"assignable"`
	LogicalPartition GlobalServiceLogicalPartitionType `json:"logicalPartition"`
	CreatedAt        time.Time                         `json:"createdAt"`
}

type GlobalServiceHierarchyDetail struct {
	ServiceID       uuid.UUID                    `json:"serviceId"`
	HierarchyName   string                       `json:"hierarchyName"`
	HierarchyType   GlobalServiceHierarchyType   `json:"hierarchyType"`
	HierarchyResult GlobalServiceHierarchyResult `json:"hierarchyResult"`
}

type GlobalTemporaryMedium struct {
	ID         uuid.UUID             `json:"id"`
	BucketPath string                `json:"bucketPath"`
	UploadType GlobalMediaUploadType `json:"uploadType"`
	MediaType  GlobalMediaType       `json:"mediaType"`
	UploadID   *string               `json:"uploadId"`
	ExpiresAt  time.Time             `json:"expiresAt"`
}

type GlobalUser struct {
	ID               uuid.UUID        `json:"id"`
	Email            string           `json:"email"`
	NormalizedEmail  string           `json:"normalizedEmail"`
	Name             string           `json:"name"`
	NormalizedName   string           `json:"normalizedName"`
	ProfilePictureID *uuid.UUID       `json:"profilePictureId"`
	About            *string          `json:"about"`
	DateOfBirth      pgtype.Date      `json:"dateOfBirth"`
	Status           GlobalUserStatus `json:"status"`
	CreatedAt        time.Time        `json:"createdAt"`
}

type GlobalUserDetail struct {
	ID                         uuid.UUID             `json:"id"`
	Email                      string                `json:"email"`
	Name                       string                `json:"name"`
	About                      *string               `json:"about"`
	DateOfBirth                pgtype.Date           `json:"dateOfBirth"`
	CreatedAt                  time.Time             `json:"createdAt"`
	ProfilePictureID           *uuid.UUID            `json:"profilePictureId"`
	Status                     GlobalUserStatus      `json:"status"`
	UncompressedProfilePicture *string               `json:"uncompressedProfilePicture"`
	ProfilePictureSize         *int64                `json:"profilePictureSize"`
	ProfilePictureStatus       NullGlobalMediaStatus `json:"profilePictureStatus"`
	Thumbnail                  *string               `json:"thumbnail"`
	Small                      *string               `json:"small"`
	Medium                     *string               `json:"medium"`
	Large                      *string               `json:"large"`
	ExtraLarge                 *string               `json:"extraLarge"`
}

type ManagementPermission struct {
	ID                uuid.UUID                 `json:"id"`
	ServiceID         uuid.UUID                 `json:"serviceId"`
	Key               string                    `json:"key"`
	AssignableActor   GlobalAssignableActorType `json:"assignableActor"`
	RequiredResources []string                  `json:"requiredResources"`
	Name              string                    `json:"name"`
	Description       *string                   `json:"description"`
	CreatedAt         time.Time                 `json:"createdAt"`
	UpdatedAt         time.Time                 `json:"updatedAt"`
}
